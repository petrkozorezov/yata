## Задача

Пользователь оформляет заказ на доставку. Он может добавить блюда, удалить, оформить заказ. После этого заказ передаётся в систему оплаты, и по результату оплаты меняет статус.

Требуется реализовать набросок приложения с взаимодействием пользователя через API-интерфейс
* Команды работают с агрегатами Order и PaymentRequest (через заглушку - HashMap, репозиторий)
* Команды выполняют нужные проверки (например, нельзя оформить пустой заказ)
* Добавление/удаление блюда — только в статусе DRAFT
* Команды эмитят события (можно просто логировать, не отправлять в брокер)
* Команды реализуют логику переходов состояний:
  - PlaceOrder — переводит в PLACED, вызывает PaymentRequested
  - MarkPaymentSucceeded → SUCCEDED → COMPLETED.
  - MarkPaymentFailed → FAILED → CANCELLED


### 1. Добавление блюда в заказ
**Команда:** `AddDishToOrder`
**Актор:** `User`
**Состояние заказа:** `DRAFT`
**Событие:** `DishAddedToOrder`

---

### 2. Удаление блюда из заказа
**Команда:** `RemoveDishFromOrder`
**Актор:** `User`
**Состояние заказа:** `DRAFT`
**Событие:** `DishRemovedFromOrder`

---

### 3. Размещение заказа
**Команда:** `PlaceOrder`
**Актор:** `User`
**Состояние заказа после выполнения:** `PLACED`
**Событие:** `OrderPlaced`

---

### 4. Создание запроса на оплату
**Реакция на событие:** `OrderPlaced`
**Команда:** `CreatePaymentRequest`
**Актор:** `PaymentService`
**Сущность:** `PaymentRequest`
**Состояние платежа:** `PENDING`
**Событие:** `PaymentRequested`

---

### 5. Успешная оплата
**Команда:** `MarkPaymentSucceeded`
**Актор:** `PaymentService`
**Состояние платежа:** `SUCCEEDED`
**Событие:** `PaymentSucceeded`
**Реакция:** `CompleteOrder`
**Состояние заказа:** `COMPLETED`
**Событие:** `OrderCompleted`

---

### 6. Ошибка при оплате
**Команда:** `MarkPaymentFailed`
**Актор:** `PaymentService`
**Состояние платежа:** `FAILED`
**Событие:** `PaymentFailed`
**Реакция:** `CancelOrder`
**Состояние заказа:** `CANCELLED`
**Событие:** `OrderCancelled`

---

**Цепочка состояний:**
`DRAFT → PLACED → PAYMENT_PENDING → (SUCCEEDED → COMPLETED | FAILED → CANCELLED)`

### Архитектура

- **Доменный слой**: агрегаты `Order` и `PaymentRequest` инкапсулируют бизнес-правила и возвращают результаты в функциональном стиле (`{:ok, state, events}`). Доменные события (`OrderPlaced`, `PaymentSucceeded` и т.д.) оформляются отдельными структурами, что упрощает аудит и построение event sourcing в будущем. Для длительных процессов используется координатор (process manager), реагирующий на события и запускающий команды других агрегатов.
- **Приложение**: командные обработчики (`OrderCommandHandler`, `PaymentCommandHandler`) принимают DTO-запросы, извлекают агрегаты из репозитория, вызывают доменные функции, фиксируют изменения и публикуют события. Репозиторий оформлен через `Behaviour`, что позволяет переключаться между ETS, Ecto/SQL и другими адаптерами без изменений доменного слоя. События распространяются через простой диспетчер (например, `GenServer`) и легко перенаправляются на внешние брокеры.
- **Интерфейсы**: gRPC-сервер отвечает за преобразование protobuf-сообщений во внутренние команды и возврат унифицированных ответов, включая read-model метод `GetOrderStatus` для выдачи снимков заказа и платежа. Внешние callback-и платежного сервиса попадают в отдельный эндпойнт, но используют те же хендлеры. Появление REST/GraphQL интерфейса не потребует переписывать бизнес-логику.
- **Инфраструктура**: модуль `Yata.Store` сохраняет агрегаты через Ecto (`orders`, `order_dishes`, `payment_requests`), события обрабатываются `EventBus.InMemory`. Конфигурация подключений и параметров окружения управляется через `config/*.exs` с поддержкой runtime overrides.
- **Тестирование**: юнит-тесты фокусируются на домене (переходы статусов, инварианты), интеграционные тесты проверяют командные хендлеры с фейковыми адаптерами, контрактные тесты покрывают gRPC API. Это упрощает безопасное развитие и регрессионный контроль.
- **Эксплуатация**: OTP-supervisor управляет `Repo`, `EventBus`, process manager-ами и прочими сервисами. Логирование команд и событий через `Logger` с метаданными обеспечивает наблюдаемость. По мере роста системы легко масштабировать шину событий, переводить репозитории на распределённые БД или добавлять очереди для асинхронной обработки. CI на GitHub Actions прогоняет `mix test` для каждого push/PR и удерживает базовую регрессию.

### TODO

- Настроить окружения (dev/prod) и автоматизировать `ecto`-таски (миграции, обновление схемы).
- Расширить тесты негативными сценариями и добавить контрактные проверки gRPC.
- Расширить read-model API списочными запросами (фильтры, пагинация заказов).
- Вынести event bus на внешний брокер или подготовить интерфейс для переключения.
